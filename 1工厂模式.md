## （一）工厂模式

先来回忆一下，我们上一节讲的静态工厂，它是通过一个工厂类根据指定的参数返回一个实例对象。

今天讲的工厂模式又叫做多态性工厂模式，指定义一个创建对象的接口，由实现这个接口的类去决定实例化哪个类，工厂方法把类的实例化延迟到子类进行。

在工厂模式中，不再由一个工厂负责所有实例，而是由工厂的子类负责。满足单一原则，也解决了产品过多时，工厂类过于臃肿的问题。（这就是静态工厂和工厂模式的区别，静态工厂经过单一性原则改造，让特定的工厂生产特定的对象，就转变成了工厂模式。）

### 1，工厂模式的设计原则

1. 抽象工厂（IFactory）：所有工厂方法的父类；
2. 具体工厂（ConcreateFactory）:实现抽象工厂的具体工厂；
3. 抽象产品（IProduct）：所有产品的父类；
4. 具体产品（ConcreateProduct）：具体产品，由具体工厂负责创建。

<img src="https://cdn.jsdelivr.net/gh/hellolsk/imageSource//imageblog/20210201093745.png" alt="image-20210201093743470" style="zoom:50%;" />

### 2，简单案例

在上例中，简单工厂维护了所有产品的的实例，违背了单一原则。工厂模式就是指定抽象工厂的子类 Java 工厂创建 Java 产品，Python 工厂创建 Python 产品。因此，他只是在简单工厂模式基础上做了单一原则的优化。所以具体代码这里不再贴出。

<img src="https://cdn.jsdelivr.net/gh/hellolsk/imageSource//imageblog/20210131214546.png" alt="image-20210131214545745" style="zoom:67%;" />

### 3，工厂模式的点评

工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。单一原则解决了简单工厂的臃肿，但当增加产品时，不仅要添加产品类，还需添加产品对应的工厂，造成系统中的类成对增加，增加了复杂度。抽象产品只能生产一种产品，此弊端可由抽象工厂解决。