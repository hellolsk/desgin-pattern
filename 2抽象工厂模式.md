## （二）抽象工厂模式

上节讲的工厂模式根据单一原则，一个工厂只生产一个对象，这样当业务复杂时系统必然会显得十分臃肿。显然没有达到我们使用设计模式的目的。当我们的产品对象可以分级分类时，是不是可以让指定工厂按照类别或是级别去创建一类对象呢？这时候我们的抽象工厂就派上用场了。

今天讲的抽象工厂模式很好的解决了工厂模式中一个工厂子类只负责创建一个产品的弊端。这里先引用一下产品族和产品等级的概念：

- 产品族：就是一个产品系，比如美的牌空调，洗衣机，电饭煲等；类似还有格力、奥克斯等；


- 产品等级：就是一个产品类，比如美的空调，格力空调，奥克斯空调等；都是空调类。


因此，当有多个产品等级结构时，抽象工厂可以用一个工厂等级结构创建多个不同产品等级结构的产品对象；而工厂方法模式面对的更多的是一个产品等级结构。这便是二者的主要区别。所以，当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

### 1，抽象工厂模式设计原则

1. 抽象工厂（IFactory）：所有工厂方法的父类；
2. 具体工厂（ConcreateFactory）:实现抽象工厂的某类具体工厂；
3. 抽象产品（IProduct）：某类产品的父类；
4. 具体产品（ConcreateProduct）：具体产品，由某类具体工厂负责创建。

<img src="https://cdn.jsdelivr.net/gh/hellolsk/imageSource//imageblog/20210201100403.png" alt="image-20210201100402130" style="zoom:50%;" />

### 2，简单案例

我们在课程产品族的基础上，增加两个产品，如课程提供录播视频和课程笔记。（将业务横向和纵向划分，横向上有 Java 和Python 课程，纵向上每个课程都有提供视频和笔记功能。）

<img src="https://cdn.jsdelivr.net/gh/hellolsk/imageSource//imageblog/20210201102900.png" alt="image-20210201102859549" style="zoom: 67%;" />

### 3，抽象工厂模式的点评

1. 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
2. 开闭原则的倾斜性：从上例中可以看出，添加一个工厂和产品族是容易的，比如 BigDataCourseFactory，但是添加产品等级如课程支持提供源码则较困难。